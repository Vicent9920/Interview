package com.example;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;

/**
 * Created by κ?? on 2017/8/26.
 */

public class Test1 {
    public static void main(String[] args) {
        String html = "<div id=\"readme\" class=\"readme blob instapaper_body\">\n" +
                "    <article class=\"markdown-body entry-content\" itemprop=\"text\"><p>#Android 内存泄漏总结</p>\n" +
                "<p>内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。</p>\n" +
                "<p>我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。</p>\n" +
                "<p>##Java 内存分配策略</p>\n" +
                "<p>Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。</p>\n" +
                "<ul>\n" +
                "<li>\n" +
                "<p>静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</p>\n" +
                "</li>\n" +
                "<li>\n" +
                "<p>栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>\n" +
                "</li>\n" +
                "<li>\n" +
                "<p>堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</p>\n" +
                "</li>\n" +
                "</ul>\n" +
                "<p>##栈与堆的区别：</p>\n" +
                "<p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。</p>\n" +
                "<p>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。</p>\n" +
                "<p>举个例子:</p>\n" +
                "<pre><code>public class Sample {\n" +
                "    int s1 = 0;\n" +
                "    Sample mSample1 = new Sample();\n" +
                "\n" +
                "    public void method() {\n" +
                "        int s2 = 1;\n" +
                "        Sample mSample2 = new Sample();\n" +
                "    }\n" +
                "}\n" +
                "\n" +
                "Sample mSample3 = new Sample();\n" +
                "</code></pre>\n" +
                "<p>Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。\n" +
                "mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。</p>\n" +
                "<p>结论：</p>\n" +
                "<p>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。―― 因为它们属于方法中的变量，生命周期随方法而结束。</p>\n" +
                "<p>成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）―― 因为它们属于类，类对象终究是要被new出来使用的。</p>\n" +
                "<p>了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。</p>\n" +
                "<p>##Java是如何管理内存</p>\n" +
                "<p>Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。</p>\n" +
                "<p>监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p>\n" +
                "<p>为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。\n" +
                "以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。</p>\n" +
                "<p><a href=\"https://camo.githubusercontent.com/ba01b8ae9af4a5e588251316c826bf3e0e695f35/687474703a2f2f7777772e69626d2e636f6d2f646576656c6f706572776f726b732f636e2f6a6176612f6c2d4a6176614d656d6f72794c65616b2f312e676966\" target=\"_blank\"><img src=\"https://camo.githubusercontent.com/ba01b8ae9af4a5e588251316c826bf3e0e695f35/687474703a2f2f7777772e69626d2e636f6d2f646576656c6f706572776f726b732f636e2f6a6176612f6c2d4a6176614d656d6f72794c65616b2f312e676966\" alt=\"\" data-canonical-src=\"http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/1.gif\" style=\"max-width:100%;\"></a></p>\n" +
                "<p>Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。</p>\n" +
                "<p>##什么是Java中的内存泄露</p>\n" +
                "<p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>\n" +
                "<p>在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p>\n" +
                "<p>通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。</p>\n" +
                "<p><a href=\"https://camo.githubusercontent.com/4845ffe2ed44807b01b7bb93647dbff85de6300f/687474703a2f2f7777772e69626d2e636f6d2f646576656c6f706572776f726b732f636e2f6a6176612f6c2d4a6176614d656d6f72794c65616b2f322e676966\" target=\"_blank\"><img src=\"https://camo.githubusercontent.com/4845ffe2ed44807b01b7bb93647dbff85de6300f/687474703a2f2f7777772e69626d2e636f6d2f646576656c6f706572776f726b732f636e2f6a6176612f6c2d4a6176614d656d6f72794c65616b2f322e676966\" alt=\"\" data-canonical-src=\"http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/2.gif\" style=\"max-width:100%;\"></a></p>\n" +
                "<p>因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。</p>\n" +
                "<p>对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。</p>\n" +
                "<p>同样给出一个 Java 内存泄漏的典型例子，</p>\n" +
                "<pre><code>Vector v = new Vector(10);\n" +
                "for (int i = 1; i &lt; 100; i++) {\n" +
                "    Object o = new Object();\n" +
                "    v.add(o);\n" +
                "    o = null;   \n" +
                "}\n" +
                "</code></pre>\n" +
                "<p>在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p>\n" +
                "<p><strong>详细Java中的内存泄漏</strong></p>\n" +
                "<p>1.Java内存回收机制</p>\n" +
                "<p>不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。</p>\n" +
                "<p>2.Java内存泄漏引起的原因</p>\n" +
                "<p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。j</p>\n" +
                "<p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：</p>\n" +
                "<p>1、静态集合类引起内存泄漏：</p>\n" +
                "<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>\n" +
                "<p>例如</p>\n" +
                "<pre><code>Static Vector v = new Vector(10);\n" +
                "for (int i = 1; i&lt;100; i++)\n" +
                "{\n" +
                "Object o = new Object();\n" +
                "v.add(o);\n" +
                "o = null;\n" +
                "}\n" +
                "</code></pre>\n" +
                "<p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p>\n" +
                "<p>2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p>\n" +
                "<p>例如：</p>\n" +
                "<pre><code>public static void main(String[] args)\n" +
                "{\n" +
                "Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();\n" +
                "Person p1 = new Person(\"唐僧\",\"pwd1\",25);\n" +
                "Person p2 = new Person(\"孙悟空\",\"pwd2\",26);\n" +
                "Person p3 = new Person(\"猪八戒\",\"pwd3\",27);\n" +
                "set.add(p1);\n" +
                "set.add(p2);\n" +
                "set.add(p3);\n" +
                "System.out.println(\"总共有:\"+set.size()+\" 个元素!\"); //结果：总共有:3 个元素!\n" +
                "p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变\n" +
                "\n" +
                "set.remove(p3); //此时remove不掉，造成内存泄漏\n" +
                "\n" +
                "set.add(p3); //重新添加，居然添加成功\n" +
                "System.out.println(\"总共有:\"+set.size()+\" 个元素!\"); //结果：总共有:4 个元素!\n" +
                "for (Person person : set)\n" +
                "{\n" +
                "System.out.println(person);\n" +
                "}\n" +
                "}\n" +
                "</code></pre>\n" +
                "<p>3、监听器</p>\n" +
                "<p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p>\n" +
                "<p>4、各种连接</p>\n" +
                "<p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p>\n" +
                "<p>5、内部类和外部模块的引用</p>\n" +
                "<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：\n" +
                "public void registerMsg(Object b);\n" +
                "这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>\n" +
                "<p>6、单例模式</p>\n" +
                "<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：</p>\n" +
                "<pre><code>class A{\n" +
                "public A(){\n" +
                "B.getInstance().setA(this);\n" +
                "}\n" +
                "....\n" +
                "}\n" +
                "//B类采用单例模式\n" +
                "class B{\n" +
                "private A a;\n" +
                "private static B instance=new B();\n" +
                "public B(){}\n" +
                "public static B getInstance(){\n" +
                "return instance;\n" +
                "}\n" +
                "public void setA(A a){\n" +
                "this.a=a;\n" +
                "}\n" +
                "//getter...\n" +
                "} \n" +
                "</code></pre>\n" +
                "<p>显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况</p>\n" +
                "<h2><a id=\"user-content-android中常见的内存泄漏汇总\" class=\"anchor\" href=\"#android中常见的内存泄漏汇总\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>##Android中常见的内存泄漏汇总</h2>\n" +
                "<p>###集合类泄漏</p>\n" +
                "<p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。</p>\n" +
                "<p>###单例造成的内存泄漏</p>\n" +
                "<p>由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子，</p>\n" +
                "<pre><code>public class AppManager {\n" +
                "private static AppManager instance;\n" +
                "private Context context;\n" +
                "private AppManager(Context context) {\n" +
                "this.context = context;\n" +
                "}\n" +
                "public static AppManager getInstance(Context context) {\n" +
                "if (instance == null) {\n" +
                "instance = new AppManager(context);\n" +
                "}\n" +
                "return instance;\n" +
                "}\n" +
                "}\n" +
                "</code></pre>\n" +
                "<p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p>\n" +
                "<p>1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。</p>\n" +
                "<p>2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。</p>\n" +
                "<p>正确的方式应该改为下面这种方式：</p>\n" +
                "<pre><code>public class AppManager {\n" +
                "private static AppManager instance;\n" +
                "private Context context;\n" +
                "private AppManager(Context context) {\n" +
                "this.context = context.getApplicationContext();// 使用Application 的context\n" +
                "}\n" +
                "public static AppManager getInstance(Context context) {\n" +
                "if (instance == null) {\n" +
                "instance = new AppManager(context);\n" +
                "}\n" +
                "return instance;\n" +
                "}\n" +
                "}\n" +
                "</code></pre>\n" +
                "<p>或者这样写，连 Context 都不用传进来了：</p>\n" +
                "<pre><code>在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context，\n" +
                "\n" +
                "...\n" +
                "\n" +
                "context = getApplicationContext();\n" +
                "\n" +
                "...\n" +
                "   /**\n" +
                "     * 获取全局的context\n" +
                "     * @return 返回全局context对象\n" +
                "     */\n" +
                "    public static Context getContext(){\n" +
                "        return context;\n" +
                "    }\n" +
                "\n" +
                "public class AppManager {\n" +
                "private static AppManager instance;\n" +
                "private Context context;\n" +
                "private AppManager() {\n" +
                "this.context = MyApplication.getContext();// 使用Application 的context\n" +
                "}\n" +
                "public static AppManager getInstance() {\n" +
                "if (instance == null) {\n" +
                "instance = new AppManager();\n" +
                "}\n" +
                "return instance;\n" +
                "}\n" +
                "}\n" +
                "</code></pre>\n" +
                "<p>###匿名内部类/非静态内部类和异步线程</p>\n" +
                "<p>非静态内部类创建静态实例造成的内存泄漏</p>\n" +
                "<p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p>\n" +
                "<pre><code>        public class MainActivity extends AppCompatActivity {\n" +
                "        private static TestResource mResource = null;\n" +
                "        @Override\n" +
                "        protected void onCreate(Bundle savedInstanceState) {\n" +
                "        super.onCreate(savedInstanceState);\n" +
                "        setContentView(R.layout.activity_main);\n" +
                "        if(mManager == null){\n" +
                "        mManager = new TestResource();\n" +
                "        }\n" +
                "        //...\n" +
                "        }\n" +
                "        class TestResource {\n" +
                "        //...\n" +
                "        }\n" +
                "        }\n" +
                "</code></pre>\n" +
                "<p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：</p>\n" +
                "<p>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>\n" +
                "<p><a href=\"https://camo.githubusercontent.com/dee4aecb8a80c4e73337b56ee01cbffa2a8049dd/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303135313132333134343232363334393f73706d3d353137362e3130303233392e626c6f67636f6e742e392e437455316334\" target=\"_blank\"><img src=\"https://camo.githubusercontent.com/dee4aecb8a80c4e73337b56ee01cbffa2a8049dd/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303135313132333134343232363334393f73706d3d353137362e3130303233392e626c6f67636f6e742e392e437455316334\" alt=\"\" data-canonical-src=\"http://img.blog.csdn.net/20151123144226349?spm=5176.100239.blogcont.9.CtU1c4\" style=\"max-width:100%;\"></a></p>\n" +
                "<p>其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建</p>\n" +
                "<p>###匿名内部类</p>\n" +
                "<p>android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露</p>\n" +
                "<pre><code>    public class MainActivity extends Activity {\n" +
                "    ...\n" +
                "    Runnable ref1 = new MyRunable();\n" +
                "    Runnable ref2 = new Runnable() {\n" +
                "        @Override\n" +
                "        public void run() {\n" +
                "\n" +
                "        }\n" +
                "    };\n" +
                "       ...\n" +
                "    }\n" +
                "</code></pre>\n" +
                "<p>ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存：</p>\n" +
                "<p><a href=\"https://camo.githubusercontent.com/2b1a52551d828d9640f23ee7c2802476b02ccec3/687474703a2f2f696d67322e746263646e2e636e2f4c312f3436312f312f666230356666366432653638663330396239346464383433353263383161636665306165383339653f73706d3d353137362e3130303233392e626c6f67636f6e742e31302e437455316334\" target=\"_blank\"><img src=\"https://camo.githubusercontent.com/2b1a52551d828d9640f23ee7c2802476b02ccec3/687474703a2f2f696d67322e746263646e2e636e2f4c312f3436312f312f666230356666366432653638663330396239346464383433353263383161636665306165383339653f73706d3d353137362e3130303233392e626c6f67636f6e742e31302e437455316334\" alt=\"\" data-canonical-src=\"http://img2.tbcdn.cn/L1/461/1/fb05ff6d2e68f309b94dd84352c81acfe0ae839e?spm=5176.100239.blogcont.10.CtU1c4\" style=\"max-width:100%;\"></a></p>\n" +
                "<p>可以看到，ref1没什么特别的。</p>\n" +
                "<p>但ref2这个匿名类的实现对象里面多了一个引用：</p>\n" +
                "<p>this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。</p>\n" +
                "<p>###Handler 造成的内存泄漏</p>\n" +
                "<p>Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。</p>\n" +
                "<p>由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。</p>\n" +
                "<p>举个例子：</p>\n" +
                "<pre><code>    public class SampleActivity extends Activity {\n" +
                "\n" +
                "    private final Handler mLeakyHandler = new Handler() {\n" +
                "    @Override\n" +
                "    public void handleMessage(Message msg) {\n" +
                "      // ...\n" +
                "    }\n" +
                "    }\n" +
                "\n" +
                "    @Override\n" +
                "    protected void onCreate(Bundle savedInstanceState) {\n" +
                "    super.onCreate(savedInstanceState);\n" +
                "\n" +
                "    // Post a message and delay its execution for 10 minutes.\n" +
                "    mLeakyHandler.postDelayed(new Runnable() {\n" +
                "      @Override\n" +
                "      public void run() { /* ... */ }\n" +
                "    }, 1000 * 60 * 10);\n" +
                "\n" +
                "    // Go back to the previous Activity.\n" +
                "    finish();\n" +
                "    }\n" +
                "    }\n" +
                "</code></pre>\n" +
                "<p>在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。</p>\n" +
                "<p>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码：</p>\n" +
                "<pre><code>public class SampleActivity extends Activity {\n" +
                "\n" +
                "  /**\n" +
                "   * Instances of static inner classes do not hold an implicit\n" +
                "   * reference to their outer class.\n" +
                "   */\n" +
                "  private static class MyHandler extends Handler {\n" +
                "    private final WeakReference&lt;SampleActivity&gt; mActivity;\n" +
                "\n" +
                "    public MyHandler(SampleActivity activity) {\n" +
                "      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);\n" +
                "    }\n" +
                "\n" +
                "    @Override\n" +
                "    public void handleMessage(Message msg) {\n" +
                "      SampleActivity activity = mActivity.get();\n" +
                "      if (activity != null) {\n" +
                "        // ...\n" +
                "      }\n" +
                "    }\n" +
                "  }\n" +
                "\n" +
                "  private final MyHandler mHandler = new MyHandler(this);\n" +
                "\n" +
                "  /**\n" +
                "   * Instances of anonymous classes do not hold an implicit\n" +
                "   * reference to their outer class when they are \"static\".\n" +
                "   */\n" +
                "  private static final Runnable sRunnable = new Runnable() {\n" +
                "      @Override\n" +
                "      public void run() { /* ... */ }\n" +
                "  };\n" +
                "\n" +
                "  @Override\n" +
                "  protected void onCreate(Bundle savedInstanceState) {\n" +
                "    super.onCreate(savedInstanceState);\n" +
                "\n" +
                "    // Post a message and delay its execution for 10 minutes.\n" +
                "    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);\n" +
                "\n" +
                "    // Go back to the previous Activity.\n" +
                "    finish();\n" +
                "  }\n" +
                "}\n" +
                "</code></pre>\n" +
                "<p>综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。</p>\n" +
                "<p>前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。</p>\n" +
                "<p>Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。</p>\n" +
                "<p><a href=\"https://camo.githubusercontent.com/068950c506eddc68677d6a84b5d7ffe1c03c6cf9/68747470733a2f2f67772e616c6963646e2e636f6d2f7470732f5442315536544e4c565858585863685846585858585858585858582d3634342d3534362e6a7067\" target=\"_blank\"><img src=\"https://camo.githubusercontent.com/068950c506eddc68677d6a84b5d7ffe1c03c6cf9/68747470733a2f2f67772e616c6963646e2e636f6d2f7470732f5442315536544e4c565858585863685846585858585858585858582d3634342d3534362e6a7067\" alt=\"\" data-canonical-src=\"https://gw.alicdn.com/tps/TB1U6TNLVXXXXchXFXXXXXXXXXX-644-546.jpg\" style=\"max-width:100%;\"></a></p>\n" +
                "<p>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p>\n" +
                "<p>软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。</p>\n" +
                "<p>假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形：</p>\n" +
                "<p>首先定义一个HashMap，保存软引用对象。</p>\n" +
                "<pre><code>private Map &lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap &lt;String, SoftReference&lt;Bitmap&gt;&gt; ();\n" +
                "</code></pre>\n" +
                "<p>再来定义一个方法，保存Bitmap的软引用到HashMap。</p>\n" +
                "<p><a href=\"https://camo.githubusercontent.com/35124988ec96dde280418c48dea872829b96fca8/68747470733a2f2f67772e616c6963646e2e636f6d2f7470732f5442316f575f464c565858585858756158585858585858585858582d3637392d3731372e6a7067\" target=\"_blank\"><img src=\"https://camo.githubusercontent.com/35124988ec96dde280418c48dea872829b96fca8/68747470733a2f2f67772e616c6963646e2e636f6d2f7470732f5442316f575f464c565858585858756158585858585858585858582d3637392d3731372e6a7067\" alt=\"\" data-canonical-src=\"https://gw.alicdn.com/tps/TB1oW_FLVXXXXXuaXXXXXXXXXXX-679-717.jpg\" style=\"max-width:100%;\"></a></p>\n" +
                "<p>使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。</p>\n" +
                "<p>如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>\n" +
                "<p>另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>\n" +
                "<p>ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。</p>\n" +
                "<p>下面几个方法都可以移除 Message：</p>\n" +
                "<pre><code>public final void removeCallbacks(Runnable r);\n" +
                "\n" +
                "public final void removeCallbacks(Runnable r, Object token);\n" +
                "\n" +
                "public final void removeCallbacksAndMessages(Object token);\n" +
                "\n" +
                "public final void removeMessages(int what);\n" +
                "\n" +
                "public final void removeMessages(int what, Object object);\n" +
                "</code></pre>\n" +
                "<p>###尽量避免使用 static 成员变量</p>\n" +
                "<p>如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。</p>\n" +
                "<p>这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，yi'wei如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。</p>\n" +
                "<p>这里修复的方法是：</p>\n" +
                "<p>不要在类初始时初始化静态成员。可以考虑lazy初始化。\n" +
                "架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p>\n" +
                "<p>###避免 override finalize()</p>\n" +
                "<p>1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是：\n" +
                "虚拟机调用GC的时间不确定\n" +
                "Finalize daemon线程被调度到的时间不确定</p>\n" +
                "<p>2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是：</p>\n" +
                "<p>含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。</p>\n" +
                "<p>3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。</p>\n" +
                "<p>###资源未关闭造成的内存泄漏</p>\n" +
                "<p>对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>\n" +
                "<p>###一些不良代码造成的内存压力</p>\n" +
                "<p>有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。</p>\n" +
                "<p>比如：\n" +
                "Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。\n" +
                "构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。</p>\n" +
                "<p>##总结</p>\n" +
                "<p>对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。</p>\n" +
                "<p>尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。</p>\n" +
                "<p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>\n" +
                "<pre><code>    将内部类改为静态内部类\n" +
                "    静态内部类中使用弱引用来引用外部类的成员变量\n" +
                "</code></pre>\n" +
                "<p>Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable.</p>\n" +
                "<p>在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。</p>\n" +
                "<p>正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。</p>\n" +
                "<p>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。</p>\n" +
                "</article>\n" +
                "  </div>";
        String html2 = "html5556 2262    ";
        html = html.trim();
        html2 = html2.trim();

        Document doc = Jsoup.parse(html);
        String text = doc.getElementsByTag("article").text();

        System.out.println(text);
//        System.out.println(html2);
    }

}
